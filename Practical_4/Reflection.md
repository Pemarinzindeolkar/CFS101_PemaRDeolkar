
In this practical, I worked on several key data structures and algorithms that are fundamental in computer science, especially linked lists and searching.<br>

For the singly linked list task, I created Node and LinkedList classes and implemented main operations like insertion at the front and end, deletion from the front, searching for a value, and displaying all list elements. Adding nodes to both the front and end taught me how list structure and order can change based on insertion method. Searching helped reinforce traversal concepts, and removing the front node showed how pointers update when deleting. Seeing the list before and after each operation gave me a clearer picture of how singly linked lists work and how important careful pointer management is. I also saw that searching in a linked list is a linear operation, confirming what I studied in the theory.<br>

The reverse_linked_list part let me practice building and reversing a singly linked list by changing the direction of node links. I also tried merging two sorted lists and removing the nth node from the end. Using the Solution class’s reverse method gave exposure to both function-based and object-oriented approaches. Each time, I made sure to build test lists, run the function, and print results, which really helped me gain hands-on understanding of how these list operations transform data.<br>

Implementing the binary search function made me think differently, since binary search only works on sorted arrays. I learned how to move the left and right pointers based on comparison at the middle index, and step-by-step tracing revealed how quickly the search area shrinks. The trace outputs with each subarray made following the algorithm much easier, and I could precisely see where and why decisions were made. This exercise highlighted the speed advantages of binary search compared to linear search.<br>

For the further exercises, I practiced additional linked list challenges like finding the middle element, detecting cycles in a list, removing duplicate nodes, and merging two sorted linked lists. Finding the middle used the classic slow and fast pointer technique, while cycle detection followed a similar approach. Removing duplicates required tracking seen elements using a set, and merging required pointer management and comparing node values to maintain order. Each time, I printed the list to verify my results.<br>

These coding exercises deepened my understanding of data structures, especially linked lists and their operations. I learned the value of thoroughly testing each function and using prints to trace changes. I also became more confident with pointer logic and how to change list links safely. Debugging and tracing outputs was key to catching mistakes, especially in reverse and merge functions.<br>

Challenges<br>
I sometimes struggled with pointer updates—for example, making sure not to lose reference to the rest of the list during reversal or node removal. Careful tracing and drawing small list diagrams helped. With cycle detection, I had to double-check my implementation to avoid infinite loops. Debug outputs and step-by-step prints, as well as reviewing tutorials and guides, were very helpful for troubleshooting.<br>

Overall, this practical session helped me connect theory to real code, showing how simple operations and careful checking are critical for building correct and efficient algorithms.<br>

