
In this practical, I worked with both binary search trees and graph data structures. For the binary search tree, I first created the tree and inserted several values. I then used the search function to look for specific values, noting that it returned None when the value was not in the tree. I performed in-order, pre-order, and post-order traversals to observe different ways of visiting tree nodes. After removing a node, I checked the in-order result to confirm the tree updated correctly.<br>

With the graph, I built an undirected graph by adding vertices and edges. I printed out the graph to verify connections. I tested depth-first search (DFS) and breadth-first search (BFS) starting from vertex 0, printing each node as visited. I found all possible paths between two nodes, which helped me understand path-finding in graphs. I used a function to check if the graph was connected and saw that after adding a disconnected vertex, the graph became not connected, as expected.<br>

Working through these exercises gave me more confidence using tree and graph algorithms in Python. The traversals and search results made it clear how nodes are visited or managed. I also learned about how changes—like deletion or adding disconnected nodes—can quickly change the entire structure. Trace outputs and clear function steps helped me spot mistakes and understand how each operation transforms the data. Overall, this practical taught me more about building, searching, updating, and analyzing trees and graphs, and why these structures are so important in algorithms.<br>
